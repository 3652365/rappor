#!/usr/bin/python
#
# Copyright 2014 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tool to run RAPPOR on simulated client input.

It takes a 2-column CSV file as generated by gen_sim_data.py.  Example:

1,s10 s55 s1 s15 s29 s57 s6
2,s20 s61 s9 s21 s39 s64 s32 s6 s49
...
<client N>,<client N's space-separated raw data>

We output 4 files:
  - params: RAPPOR parameters, needed to recover distributions from the output
  - out: output the total counts of the bloom filter bits set by RAPPOR on
    input data
  - map file: candidate strings and hashes; required for RAPPOR
  - hist: histogram of actual input values.  Compare this with the histogram
    the RAPPOR analysis infers from the first 3 values.
"""

import collections
import getopt
import os
import random
import sys
import time

import rappor  # client library
try:
  import fastrand
except ImportError:
  print >>sys.stderr, (
      "Native fastrand module not imported; see README for speedups")
  fastrand = None


# Error flags
PARSE_SUCCESS = 0
PARSE_ERROR = 1


def log(msg, *args):
  if args:
    msg = msg % args
  print >>sys.stderr, msg


class RapporInstance(object):
  """Simple class to create a RAPPOR instance with specific default params."""
  def __init__(self):
    self.params = rappor.Params()

    self.infile = ""             # Input file name; must be user-provided
    self.outfile = ""            # Output file name
    self.histfile = ""           # Output histogram file
    self.mapfile = ""            # Output BF map file
    self.paramsfile = ""         # Output params file
    self.randomness_seed = None  # Randomness seed
                                 # For debugging purposes only

    # TODO: Add orthogonal flag for crytographic randomness.
    self.random_mode = 'fast'    # simple/fast.

  # For testing
  def __eq__(self, other):
    return self.__dict__ == other.__dict__

  def __repr__(self):
    return repr(self.__dict__)


def parse_args(argv):
  """Parse and validate flags."""
  try:
    opts, args = getopt.getopt(
        argv[1:], "i:o:p:q:f:c:nh:hf:m:pf:s:r:",
        ["input=", "output=", "cohorts=",
         "hashes=", "bloombits=", "oneprr",
         "mapfile=", "rseed="])
  except getopt.GetoptError:
    usage(argv[0])
    sys.exit(2)

  inst = RapporInstance()
  for opt, arg in opts:
    if opt in ("-i", "--input"):
      inst.infile = arg
    elif opt in ("-o", "--output"):
      inst.outfile = arg

    # Privacy params
    elif opt in ("-b", "--bloombits"):
      inst.params.num_bloombits = int(arg)
    elif opt in ("-nh", "--hashes"):
      inst.params.num_hashes = int(arg)
    elif opt in ("-c", "--cohorts"):
      inst.params.num_cohorts = int(arg)
    elif opt == "-p":
      inst.params.prob_p = float(arg)
    elif opt == "-q":
      inst.params.prob_q = float(arg)
    elif opt == "-f":
      inst.params.prob_f = float(arg)
    # Pseudo-param
    elif opt == "--oneprr":
      inst.params.flag_oneprr = True

    elif opt == "-r":
      VALID = ('simple', 'fast')
      arg = arg.strip()
      if arg not in VALID:
        raise RuntimeError('random most must be one of: %s' % ' '.join(VALID))
      inst.random_mode = arg
    elif opt == "-hf":
      inst.histfile = arg
    elif opt in ("-m", "--mapfile"):
      inst.mapfile = arg
    elif opt == "-pf":
      inst.paramsfile = arg
    elif opt in ("-s", "--rseed"):
      inst.randomness_seed = arg

  # Warn anyone that accidentally turns on the flag
  if inst.randomness_seed is not None:
    sys.stdout.write("""

    WARNING! Randomness should be seeded with time or good entropy sources to
    ensure freshness. -s/--seed command line flag is for debugging purposes
    only.

    \n""")

  if not inst.infile:
    return inst, PARSE_ERROR

  prefix, _ = os.path.splitext(inst.infile)
  inst.outfile = inst.outfile or (prefix + "_out.csv")
  inst.histfile = inst.histfile or (prefix + "_hist.csv")
  inst.mapfile = inst.mapfile or (prefix + "_map.csv")
  inst.paramsfile = inst.paramsfile or (prefix + "_params.csv")

  return inst, PARSE_SUCCESS


def usage(script_name):
  sys.stdout.write("Usage: " + script_name + " --input/-i <input file name>")
  sys.stdout.write(" [-o|c|nh|p|q|f|b] [--oneprr]")

  sys.stdout.write("""

  -o or --output        Output file name
  -r simple/fast        Random algorithm
  -c or --cohorts       Number of cohorts
  -nh or --hashes       Number of hashes
  -p                    Probability p
  -q                    Probability q
  -f                    Probability f
  -b or --bloombits     Size of bloom filter in bits
  -pf                   Parameters file
  -m or --mapfile       Bloom filter map file
  --oneprr              Include flag to set one PRR for each (user,word)

""")


PARAMS_HTML = """
  <h3>RAPPOR Parameters</h3>
  <table align="center">
    <tr>
      <td><b>k</b></td>
      <td>Size of Bloom filter in bits</td>
      <td align="right">{}</td>
    </tr>
    <tr>
      <td><b>h</b></td>
      <td>Hash functions in Bloom filter</td>
      <td align="right">{}</td>
    </tr>
    <tr>
      <td><b>m</b></td>
      <td>Number of Cohorts</td>
      <td align="right">{}</td>
    </tr>
    <tr>
      <td><b>p</b></td>
      <td>Probability p</td>
      <td align="right">{}</td>
    </tr>
    <tr>
      <td><b>q</b></td>
      <td>Probability q</td>
      <td align="right">{}</td>
    </tr>
    <tr>
      <td><b>f</b></td>
      <td>Probability f</td>
      <td align="right">{}</td>
    </tr>
  </table>
"""


def print_params(params, csv_out, html_out):
  """Print Rappor parameters to a text file."""
  row = (
      params.num_bloombits,
      params.num_hashes,
      params.num_cohorts,
      params.prob_p,
      params.prob_q,
      params.prob_f)
  print >>csv_out, "k,h,m,p,q,f\n"  # CSV header
  print >>csv_out, "%s,%s,%s,%s,%s,%s\n" % row

  # NOTE: No HTML escaping since we're writing numbers
  print >>html_out, PARAMS_HTML.format(*row)


def make_histogram(infile):
  """Make a histogram of the simulated input file."""
  # TODO: It would be better to share parsing with rappor_encode()
  words_counter = collections.Counter()
  for line in infile:
    _, words = line.strip().split(",")
    words_counter.update(words.split())
  return dict(words_counter.most_common())


def print_map(all_words, params, mapfile):
  """Print Bloom Filter map of values from infile."""
  # Print maps of distributions
  # Required by the R analysis tool
  k = params.num_bloombits
  for word in all_words:
    mapfile.write(word)
    for cohort in xrange(params.num_cohorts):
      for hash_no in xrange(params.num_hashes):
        bf_bit = rappor.get_bf_bit(word, cohort, hash_no, k) + 1
        mapfile.write("," + str(cohort * k + bf_bit))
    mapfile.write("\n")


def print_histogram(word_hist, histfile):
  """Write histogram of infile to histfile."""
  # Print histograms of distributions
  sorted_words = sorted(word_hist.iteritems(), key=lambda pair: pair[1],
                        reverse=True)
  fmt = "%s,%s"
  print >>histfile, fmt % ("string", "count")
  for pair in sorted_words:
    print >>histfile, fmt % pair


def rappor_encode(params, rand_funcs, infile):
  start_time = time.time()
  for i, line in enumerate(infile):
    user_id, words_str = line.strip().split(",")
    words = words_str.split()

    if i % 1000 == 0:
      elapsed = time.time() - start_time
      log('Processed %d inputs in %.2f seconds', i, elapsed)

    # New encoder instance for each user.
    e = rappor.Encoder(params, user_id, rand_funcs=rand_funcs)
    yield user_id, [e.encode(w) for w in words]


def bit_string(irr, num_bloombits):
  """Like bin(), but uses leading zeroes, and no '0b'."""
  s = ''
  bits = []
  for bit_num in xrange(num_bloombits):
    if irr & (1 << bit_num):
      bits.append('1')
    else:
      bits.append('0')
  return ''.join(reversed(bits))


def main(argv):
  inst, ret_val = parse_args(argv)
  if ret_val == PARSE_ERROR:
    usage(argv[0])
    sys.exit(2)

  params = inst.params

  params_csv = inst.paramsfile
  base, _ = os.path.splitext(params_csv)
  params_html = base + '.html'

  # Print parameters to parameters file -- needed for the R analysis tool.
  with open(params_csv, 'w') as csv_out:
    with open(params_html, 'w') as html_out:
      print_params(params, csv_out, html_out)

  with open(inst.infile) as f:
    word_hist = make_histogram(f)

  # Print true histograms.
  with open(inst.histfile, 'w') as f:
    print_histogram(word_hist, f)

  # Print maps to map file -- needed for the R analysis tool.
  all_words = sorted(word_hist)  # unique words
  with open(inst.mapfile, 'w') as f:
    print_map(all_words, params, f)

  rand = random.Random()  # default Mersenne Twister randomness
  #rand = random.SystemRandom()  # cryptographic randomness from OS

  if inst.randomness_seed is not None:
    rand.seed(inst.randomness_seed)  # Seed with cmd line arg
    log('Seeded to %r', inst.randomness_seed)
  else:
    rand.seed()  # Default: seed with sys time

  if inst.random_mode == 'simple':
    rand_funcs = rappor.SimpleRandFuncs(params, rand)
  elif inst.random_mode == 'fast':
    if fastrand:
      log('Using fastrand extension')
      # NOTE: This doesn't take 'rand'
      rand_funcs = fastrand.FastRandFuncs(params)
    else:
      log('Warning: fastrand module not importable; see README for build '
          'instructions.  Falling back to simple randomness.')
      rand_funcs = rappor.SimpleRandFuncs(params, rand)
  else:
    raise AssertionError

  # Do RAPPOR transformation.
  with open(inst.infile) as inf, open(inst.outfile, 'w') as outf:
    for user_id, encoded in rappor_encode(params, rand_funcs, inf):
      # encoded is a list of (cohort, rappor) pairs
      row = [user_id]
      for cohort, irr in encoded:
        row.append('%s %s' % (cohort, bit_string(irr, params.num_bloombits)))
      print >>outf, ','.join(row)


if __name__ == "__main__":
  try:
    main(sys.argv)
  except RuntimeError, e:
    log('rappor_sim.py: FATAL: %s', e)
